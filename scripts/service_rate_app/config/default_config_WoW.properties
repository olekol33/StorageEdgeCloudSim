#default config file
# Affects request generation and object placement
random_seed=42
# Sim time in minutes. If used with external requests file, should be equal or larger last request time stamp.
simulation_time=10.5
# Period (in minutes) in which results are ignored.
warm_up_period=1
# Runtime intervals of updateMM1QueueModel()  (updating queue aggregated parameters)
mm1_queue_model_update_interval=1
# Fixed value indicating time to access data
request_processing_time=0.002

#Logging
file_log_enabled=true
deep_file_log_enabled=false
storage_log_enabled=false

#Generate edge_devices.xml automatically by number_of_edge_nodes, basically shouldn't change
gen_edge_devices_xml=true

# Toggles getSignalAttenuation(), adding signal attenuation (delay) to the latency
applySignalAttenuation=false
# Display simulation runtime
measure_simulation_runtime=false
# Break a run if % of failed requests exceeds fail_threshold
terminate_failed_run=true
fail_threshold=0.02
# If using external requests, must match the number of nodes (ignore, used from external file)
number_of_edge_datacenters=100
# Number of mobile devices (i.e., users)
num_of_mobile_devices=100
# If true, users are placed in nodes (i.e., no additional user-node delay)
user_in_nodes=true
#Fixed network delay (seconds)
network_delay=0.001
# Maximum time a request can spend in the queue (seconds)
queue_timeout=0.1
# Node-user delay (seconds)
delay_to_user=0

# Redundancy policy  (can also run each one separately)
# Object redundancy policy used in the simulation: 0 - coding, 1 - replication, 2 - coding followed by replication
redundancy_policy=2

#grid properties - x and y range of the grid, host radius (used for associating to access nodes)
# If using external file, ensure that the grid size is large enough to accommodate all nodes and devices
# Basically shouldn't change at all
x_range=3000
y_range=3000
host_radius=10

# Request generation properties
zipf_exponent=1
## reqs per second per node (matches expected input ~15K/sec)
readRate=189

#storage properties
## Storage overhead, mostly used 1.5 and 2
overhead=1.5
## Distribution of object placement and reads (accepts values UNIFORM/ZIPF)
## (ignore, used from external file)
object_dist_read=UNIFORM
object_dist_place=UNIFORM
## Used in erasure coding, step to increase/decrease probability of reading parity (basically shouldn't change)
parityProbStep=0.001

#Object properties (ignore, used from external file)
num_of_data_objects=100
## Assumed stripes of 2 data + 1 parity. Use 30 to have at least one data object in each stripe.
num_of_stripes=100

#Host failure (only for fail scenario, toggle with host_failure_scenario)
host_failure_scenario=false
## If true, probabilistic failure is used, otherwise deterministic
probabilistic_failure=false
## If deterministic, these fail
host_failure_id=2,3
## Failure can occur after host_failure_time (minutes). If deterministic, failure occurs at this time.
host_failure_time=15

#Capacity to process incoming object requests (simulate node-node BW in ORBIT)
# Adjusted for 100 nodes
taskProcessingMbps=99000

####Experiments#####
#Service rate scan - main experiment (otherwise lambda scan)
service_rate_scan=true

#ORBIT - obsolete
orbit_mode=false
simulate_orbit_mode=false
##Adjusts read rate in WLAN queue
sim2orbit_readrate_ratio=1


##set true to append results to DEMAND file in the service rate experiment - basically not desired
keep_service_rate_file=true
service_rate_iterations=1
request_rate_utilization=0.8

##relevant only for ORBIT, otherwise ignored
current_service_rate_iteration=1
overhead_scan_mean_ratio=1
overhead_scan_std=0.05

# Requested object locations
## 0 - inactive, 1 - at access node, 2 - at remote node
requested_object_location=0
## after request set generation, set location of user i at location of (i+1)%n
shift_device_location=false
## two classes of uniform (sets object_dist_read=true)
hot_cold_uniform=false
hot_to_cold_object_ratio=2,1
hot_to_cold_popularity_ratio=9,1


#Input properties
## If input is in form of latitudes and longitudes, set to true
gps_coordinates_conversion=false
## Toggle external input
external_nodes_input=true
external_devices_input=true
external_objects_input=true
external_requests_input=true
## Toggle external input from *_PLACEMENT.csv - use placement from previous run to recreate the same scenario
external_objects_input_from_placement_csv=false
# Used for a specific experiment where a object was split into multiple objects - can ignore
map_large_object_input_to_small=false

## Dir paths to the input files (if not in default location)
nodes_direct_path=
devices_direct_path=
objects_direct_path=
requests_direct_path=
